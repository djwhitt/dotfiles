#!/usr/bin/env bun
import { existsSync, watch, type FSWatcher } from "fs";
import { appendFile, mkdtemp, readFile, readdir, rm, unlink, writeFile } from "fs/promises";
import { tmpdir } from "os";
import path from "path";

const HELP_TEXT = `Usage: live-display [JSON_FILE]

Watches a JSON file and displays diagrams/images in Kitty terminal.

Arguments:
  JSON_FILE    Path to JSON file (default: .live-display.json in git root)

Supported diagram types: plantuml, dot, gnuplot, ditaa
Supported image types: png, jpg, jpeg, gif, bmp, webp, svg
`;

const EXTENSION_TYPE_MAP: Record<string, string> = {
  '.puml': 'plantuml',
  '.plantuml': 'plantuml',
  '.dot': 'dot',
  '.gv': 'dot',
  '.gp': 'gnuplot',
  '.gnuplot': 'gnuplot',
  '.plt': 'gnuplot',
  '.ditaa': 'ditaa',
  '.dta': 'ditaa',
  '.png': 'image',
  '.jpg': 'image',
  '.jpeg': 'image',
  '.gif': 'image',
  '.bmp': 'image',
  '.webp': 'image',
  '.svg': 'image',
};

interface DiagramTool {
  name: string;
  available: boolean;
  tempPrefix: string;
  inputExtension: string;
  prepareContent?: (content: string, outputPath: string) => string;
  run: (inputPath: string, outputPath: string, tempDir: string) => Promise<string>;
}

function extractGnuplotOutputPath(content: string): string | null {
  const lines = content.split(/\r?\n/);
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) {
      continue;
    }

    const match = trimmed.match(/^set\s+out(?:put)?\s+(["'])(.*?)\1/i);
    if (match) {
      return match[2];
    }
  }

  return null;
}

function getTypeFromExtension(filePath: string): string {
  const ext = path.extname(filePath).toLowerCase();
  const type = EXTENSION_TYPE_MAP[ext];
  if (!type) {
    throw new Error(`Unsupported file extension: ${ext}`);
  }
  return type;
}

function findGitRoot(startPath: string = process.cwd()): string {
  let currentPath = path.resolve(startPath);

  while (currentPath !== path.dirname(currentPath)) {
    const gitPath = path.join(currentPath, '.git');
    if (existsSync(gitPath)) {
      return currentPath;
    }
    currentPath = path.dirname(currentPath);
  }

  // If no .git found, fall back to current working directory
  return process.cwd();
}

function isProcessRunning(pid: number): boolean {
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}

async function createPidFile(gitRoot: string): Promise<string> {
  const pidPath = path.join(gitRoot, ".live-display.pid");
  const currentPid = process.pid.toString();

  const claimPidFile = async (): Promise<void> => {
    await writeFile(pidPath, currentPid, { flag: "wx" });
  };

  try {
    await claimPidFile();
    return pidPath;
  } catch (error: any) {
    if (error.code !== "EEXIST") {
      throw error;
    }
  }

  let oldPid: number | null = null;
  try {
    oldPid = parseInt((await readFile(pidPath, "utf-8")).trim(), 10);
  } catch {
    // Ignore PID read errors and try to reclaim below
  }

  if (oldPid !== null && !isNaN(oldPid) && isProcessRunning(oldPid)) {
    throw new Error(`another live-display process is already running (PID ${oldPid})`);
  }

  try {
    await unlink(pidPath);
  } catch {
    // Ignore unlink errors and retry claim
  }

  try {
    await claimPidFile();
    return pidPath;
  } catch (error: any) {
    if (error.code === "EEXIST") {
      const latestPid = parseInt((await readFile(pidPath, "utf-8")).trim(), 10);
      throw new Error(`unable to claim PID file; active live-display PID is ${latestPid}`);
    }
    throw error;
  }
}

async function removePidFile(pidPath: string): Promise<void> {
  try {
    const pidContent = (await readFile(pidPath, "utf-8")).trim();
    if (pidContent !== process.pid.toString()) {
      return;
    }
    await unlink(pidPath);
  } catch {
    // Ignore errors when removing PID file
  }
}

interface DisplayItem {
  type?: string;
  content?: string;
  file?: string;
  title?: string;
}

interface DisplayData {
  items: DisplayItem[];
}

type DisplayOutcome = 'rendered' | 'skipped' | 'failed';

function validateDisplayData(data: unknown): DisplayData {
  if (!data || typeof data !== "object") {
    throw new Error("Invalid JSON: expected an object");
  }

  const obj = data as Record<string, unknown>;

  if (!Array.isArray(obj.items)) {
    throw new Error("Invalid JSON: 'items' must be an array");
  }

  const items: DisplayItem[] = [];
  for (let i = 0; i < obj.items.length; i++) {
    const item = obj.items[i];
    if (!item || typeof item !== "object") {
      throw new Error(`Invalid JSON: item ${i} must be an object`);
    }

    const itemObj = item as Record<string, unknown>;

    // Must have either 'file' or both 'type' and 'content'
    const hasFile = itemObj.file !== undefined;
    const hasTypeContent = itemObj.type !== undefined && itemObj.content !== undefined;

    if (!hasFile && !hasTypeContent) {
      throw new Error(`Invalid JSON: item ${i} must have either 'file' or both 'type' and 'content'`);
    }

    if (hasFile && hasTypeContent) {
      throw new Error(`Invalid JSON: item ${i} cannot have both 'file' and 'type'/'content' - choose one approach`);
    }

    if (itemObj.file !== undefined && typeof itemObj.file !== "string") {
      throw new Error(`Invalid JSON: item ${i} 'file' must be a string`);
    }

    if (itemObj.type !== undefined && typeof itemObj.type !== "string") {
      throw new Error(`Invalid JSON: item ${i} 'type' must be a string`);
    }

    if (itemObj.content !== undefined && typeof itemObj.content !== "string") {
      throw new Error(`Invalid JSON: item ${i} 'content' must be a string`);
    }

    if (itemObj.title !== undefined && typeof itemObj.title !== "string") {
      throw new Error(`Invalid JSON: item ${i} 'title' must be a string if provided`);
    }

    items.push({
      type: itemObj.type as string | undefined,
      content: itemObj.content as string | undefined,
      file: itemObj.file as string | undefined,
      title: itemObj.title as string | undefined,
    });
  }

  return { items };
}

class DisplayHandler {
  private jsonPath: string;
  private gitRoot: string;
  private logFilePath: string;
  private diagramTools: Record<string, DiagramTool> = {};
  private activeTempDirs = new Set<string>();
  private previousTempDirs = new Set<string>();
  private fileWatchers = new Map<string, FSWatcher>();
  private updateTimeout: ReturnType<typeof setTimeout> | null = null;
  private updating = false;
  private pendingUpdate = false;
  private readonly DEBOUNCE_MS = 100;

  constructor(jsonPath: string) {
    this.jsonPath = path.resolve(jsonPath);
    this.gitRoot = findGitRoot();
    this.logFilePath = path.join(this.gitRoot, '.live-display.log');
    this.initializeDiagramTools();
    Bun.write(this.logFilePath, `[${new Date().toISOString()}] live-display started (PID ${process.pid})\n`);
  }

  private async log(message: string): Promise<void> {
    const timestamp = new Date().toISOString();
    try {
      await appendFile(this.logFilePath, `[${timestamp}] ${message}\n`);
    } catch {
      // Ignore logging errors
    }
  }

  private initializeDiagramTools(): void {
    this.diagramTools = {
      plantuml: {
        name: 'PlantUML',
        available: false,
        tempPrefix: 'live-display-puml-',
        inputExtension: '.puml',
        run: async (inputPath, _outputPath, tempDir) => {
          await this.runCommand(['plantuml', '-tpng', '-o', tempDir, inputPath], 'PlantUML');
          // PlantUML names output based on input file, so find the generated PNG
          const files = await readdir(tempDir);
          const pngFiles = files.filter(f => f.endsWith('.png'));
          if (pngFiles.length === 0) {
            throw new Error("No PNG file generated by PlantUML");
          }
          return path.join(tempDir, pngFiles[0]);
        },
      },
      dot: {
        name: 'Graphviz DOT',
        available: false,
        tempPrefix: 'live-display-dot-',
        inputExtension: '.dot',
        run: async (inputPath, outputPath) => {
          await this.runCommand(['dot', '-Tpng', inputPath, '-o', outputPath], 'Graphviz');
          return outputPath;
        },
      },
      gnuplot: {
        name: 'Gnuplot',
        available: false,
        tempPrefix: 'live-display-gnuplot-',
        inputExtension: '.gp',
        prepareContent: (content, outputPath) => {
          // Check if script already has terminal settings (only match uncommented lines)
          const hasTerminal = /^\s*set\s+term(inal)?[\s]/im.test(content);
          const hasOutput = /^\s*set\s+out(put)?[\s]/im.test(content);

          if (!hasTerminal || !hasOutput) {
            // Prepend PNG terminal settings if not present
            return `set terminal png size 800,600\nset output "${outputPath}"\n${content}`;
          }
          return content;
        },
        run: async (inputPath, outputPath, tempDir) => {
          await this.runCommand(['gnuplot', inputPath], 'Gnuplot');

          if (existsSync(outputPath)) {
            return outputPath;
          }

          const inputContent = await readFile(inputPath, 'utf-8');
          const configuredOutput = extractGnuplotOutputPath(inputContent);
          if (configuredOutput) {
            const candidate = path.isAbsolute(configuredOutput)
              ? configuredOutput
              : path.join(tempDir, configuredOutput);

            if (existsSync(candidate)) {
              return candidate;
            }

            throw new Error(`Gnuplot did not produce expected output file: ${candidate}`);
          }

          throw new Error(`Gnuplot did not produce an output file: ${outputPath}`);
        },
      },
      ditaa: {
        name: 'Ditaa',
        available: false,
        tempPrefix: 'live-display-ditaa-',
        inputExtension: '.ditaa',
        run: async (inputPath, outputPath) => {
          await this.runCommand(['ditaa', inputPath, outputPath], 'Ditaa');
          return outputPath;
        },
      },
    };
  }

  async checkToolAvailability(): Promise<void> {
    const checks: [string, string[]][] = [
      ['plantuml', ['plantuml', '-version']],
      ['dot', ['dot', '-V']],
      ['gnuplot', ['gnuplot', '--version']],
      ['ditaa', ['ditaa', '--help']],
    ];

    for (const [toolName, command] of checks) {
      try {
        const proc = Bun.spawn(command, { stdout: 'pipe', stderr: 'pipe' });
        await proc.exited;
        this.diagramTools[toolName].available = proc.exitCode === 0;
      } catch {
        this.diagramTools[toolName].available = false;
      }
    }
  }

  private async runCommand(command: string[], toolName: string, cwd?: string): Promise<void> {
    await this.log(`Running: ${command.join(' ')}`);
    const proc = Bun.spawn(command, { stdout: 'pipe', stderr: 'pipe', cwd });
    await proc.exited;

    if (proc.exitCode !== 0) {
      const stderr = await new Response(proc.stderr).text();
      throw new Error(`${toolName} failed: ${stderr}`);
    }
  }

  private resolveFilePath(filePath: string): string {
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    return path.join(this.gitRoot, filePath);
  }

  scheduleUpdate(): void {
    if (this.updateTimeout) {
      clearTimeout(this.updateTimeout);
    }
    this.updateTimeout = setTimeout(() => this.updateDisplay(), this.DEBOUNCE_MS);
  }

  async updateDisplay(): Promise<void> {
    if (this.updating) {
      this.pendingUpdate = true;
      return;
    }
    this.updating = true;

    try {
      await this.cleanupTempDirSet(this.previousTempDirs);

      // Rotate: previous dirs are now safe to delete, active become previous
      this.previousTempDirs = this.activeTempDirs;
      this.activeTempDirs = new Set<string>();

      const content = await readFile(this.jsonPath, "utf-8");
      const data = validateDisplayData(JSON.parse(content));

      const referencedFiles = new Set<string>();
      for (const item of data.items) {
        if (item.file) {
          referencedFiles.add(this.resolveFilePath(item.file));
        }
      }
      await this.updateFileWatchers(referencedFiles);

      console.clear();

      const summary = {
        rendered: 0,
        skipped: 0,
        failed: 0,
      };

      for (let i = 0; i < data.items.length; i++) {
        if (i > 0) {
          console.log("\n" + "-".repeat(50) + "\n");
        }
        try {
          const outcome = await this.displayItem(data.items[i]);
          summary[outcome] += 1;
        } catch (error: any) {
          summary.failed += 1;
          await this.log(`Unexpected item error: ${error.message}`);
          console.log(`Unexpected item error: ${error.message}`);
        }
      }

      console.log(
        `\nRefresh complete: ${summary.rendered} rendered, ${summary.skipped} skipped, ${summary.failed} failed`
      );

      if (data.items.length === 0) {
        console.log("No items configured. Add entries to .live-display.json to render content.");
      }

    } catch (error: any) {
      if (error.code === "ENOENT") {
        console.log(`Waiting for ${this.jsonPath} to be created...`);
      } else if (error instanceof SyntaxError) {
        console.log(`Error parsing JSON: ${error.message}`);
      } else {
        console.log(`Error: ${error.message}`);
      }
    } finally {
      this.updating = false;
      if (this.pendingUpdate) {
        this.pendingUpdate = false;
        this.scheduleUpdate();
      }
    }
  }

  private async displayItem(item: DisplayItem): Promise<DisplayOutcome> {
    if (item.title) {
      console.log(`\n${item.title}\n`);
    }

    // Inline content
    if (!item.file) {
      const type = item.type!;
      if (type === "image") {
        console.log("Inline image content not supported");
        return 'skipped';
      } else if (this.diagramTools[type]) {
        return this.renderDiagram(type, item.content!);
      } else {
        console.log(`Unsupported display type: ${type}`);
        return 'skipped';
      }
    }

    // File-based content
    const filePath = this.resolveFilePath(item.file);
    let type: string;
    try {
      type = getTypeFromExtension(item.file);
    } catch (error: any) {
      console.log(`Unsupported file type for ${item.file}: ${error.message}`);
      return 'skipped';
    }

    if (!existsSync(filePath)) {
      console.log(`File not found: ${filePath}`);
      return 'skipped';
    }

    if (type === "image") {
      try {
        await this.displayImage(filePath);
        return 'rendered';
      } catch (error: any) {
        await this.log(`Error displaying image: ${error.message}`);
        console.log(`Error displaying image: ${error.message}`);
        return 'failed';
      }
    }

    if (this.diagramTools[type]) {
      return this.renderDiagramFile(type, filePath);
    }

    console.log(`Unsupported display type: ${type}`);
    return 'skipped';
  }

  private async displayImage(imagePath: string): Promise<void> {
    await this.log(`Displaying image: ${imagePath}`);

    const proc = Bun.spawn(["kitty", "+kitten", "icat", imagePath], {
      stdout: "inherit",
      stderr: "pipe",
      stdin: "inherit",
    });

    await proc.exited;

    if (proc.exitCode !== 0) {
      const stderr = await new Response(proc.stderr).text();
      if (stderr && !stderr.includes("ImageMagick")) {
        await this.log(`kitty icat stderr: ${stderr}`);
        throw new Error(`Image display failed: ${stderr}`);
      }
    }
  }

  private async renderDiagram(type: string, content: string): Promise<DisplayOutcome> {
    const tool = this.diagramTools[type];

    if (!tool.available) {
      console.log(`${tool.name} is not available on this system`);
      return 'skipped';
    }

    await this.log(`Rendering ${tool.name} diagram`);

    try {
      const tempDir = await mkdtemp(path.join(tmpdir(), tool.tempPrefix));
      this.activeTempDirs.add(tempDir);

      const outputPath = path.join(tempDir, "output.png");
      const inputPath = path.join(tempDir, `input${tool.inputExtension}`);

      const preparedContent = tool.prepareContent
        ? tool.prepareContent(content, outputPath)
        : content;
      await writeFile(inputPath, preparedContent);

      const actualOutputPath = await tool.run(inputPath, outputPath, tempDir);
      await this.displayImage(actualOutputPath);
      return 'rendered';

    } catch (error: any) {
      await this.log(`Error in ${tool.name} rendering: ${error.message}`);
      console.log(`Error rendering ${tool.name}: ${error.message}`);
      return 'failed';
    }
  }

  private async renderDiagramFile(type: string, filePath: string): Promise<DisplayOutcome> {
    const tool = this.diagramTools[type];

    if (!tool.available) {
      console.log(`${tool.name} is not available on this system`);
      return 'skipped';
    }

    await this.log(`Rendering ${tool.name} diagram from file: ${filePath}`);

    try {
      const sourceDir = path.dirname(filePath);
      const tempDir = await mkdtemp(path.join(tmpdir(), tool.tempPrefix));
      this.activeTempDirs.add(tempDir);

      const outputPath = path.join(tempDir, "output.png");
      let actualOutputPath = outputPath;

      if (type === 'plantuml') {
        await this.runCommand(['plantuml', '-tpng', '-o', tempDir, filePath], 'PlantUML', sourceDir);
        const files = await readdir(tempDir);
        const pngFiles = files.filter(f => f.endsWith('.png'));
        if (pngFiles.length === 0) {
          throw new Error("No PNG file generated by PlantUML");
        }
        actualOutputPath = path.join(tempDir, pngFiles[0]);
      } else if (type === 'dot') {
        await this.runCommand(['dot', '-Tpng', filePath, '-o', outputPath], 'Graphviz', sourceDir);
      } else if (type === 'ditaa') {
        await this.runCommand(['ditaa', filePath, outputPath], 'Ditaa', sourceDir);
      } else if (type === 'gnuplot') {
        await this.runCommand(['gnuplot', filePath], 'Gnuplot', sourceDir);

        if (!existsSync(outputPath)) {
          const scriptContent = await readFile(filePath, 'utf-8');
          const configuredOutput = extractGnuplotOutputPath(scriptContent);
          actualOutputPath = configuredOutput
            ? (path.isAbsolute(configuredOutput)
                ? configuredOutput
                : path.join(sourceDir, configuredOutput))
            : path.join(sourceDir, 'gnuplot.out');
        }
      }

      if (!existsSync(actualOutputPath)) {
        throw new Error(`Diagram output file not found: ${actualOutputPath}`);
      }

      await this.displayImage(actualOutputPath);
      return 'rendered';

    } catch (error: any) {
      await this.log(`Error in ${tool.name} file rendering: ${error.message}`);
      console.log(`Error rendering ${tool.name}: ${error.message}`);
      return 'failed';
    }
  }

  private async cleanupTempDirSet(dirs: Set<string>): Promise<void> {
    for (const tempDir of dirs) {
      try {
        await rm(tempDir, { recursive: true, force: true });
      } catch {
        // Ignore cleanup errors
      }
    }
    dirs.clear();
  }

  async cleanupAllTempDirs(): Promise<void> {
    await this.cleanupTempDirSet(this.previousTempDirs);
    await this.cleanupTempDirSet(this.activeTempDirs);
  }

  private async updateFileWatchers(referencedFiles: Set<string>): Promise<void> {
    const attachFileWatcher = async (file: string): Promise<void> => {
      let watcher: FSWatcher;
      watcher = watch(file, async (eventType) => {
        if (eventType === 'rename') {
          await this.log(`Detected file replacement for: ${file}`);
          watcher.close();
          this.fileWatchers.delete(file);

          if (existsSync(file)) {
            await attachFileWatcher(file);
            await this.log(`Reattached watcher: ${file}`);
          }

          this.scheduleUpdate();
          return;
        }

        if (eventType === 'change') {
          await this.log(`Detected change in: ${file}`);
          this.scheduleUpdate();
        }
      });

      this.fileWatchers.set(file, watcher);
      await this.log(`Now watching: ${file}`);
    };

    // Remove watchers for files no longer referenced
    for (const [watchedFile, watcher] of this.fileWatchers) {
      if (!referencedFiles.has(watchedFile)) {
        watcher.close();
        this.fileWatchers.delete(watchedFile);
        await this.log(`Stopped watching: ${watchedFile}`);
      }
    }

    // Add watchers for new files
    for (const file of referencedFiles) {
      if (!this.fileWatchers.has(file) && existsSync(file)) {
        await attachFileWatcher(file);
      }
    }
  }

  cleanupFileWatchers(): void {
    for (const watcher of this.fileWatchers.values()) {
      watcher.close();
    }
    this.fileWatchers.clear();
  }
}

async function main(): Promise<void> {
  if (process.argv.includes('--help') || process.argv.includes('-h')) {
    console.log(HELP_TEXT);
    process.exit(0);
  }

  if (!process.env.KITTY_WINDOW_ID) {
    console.error("Error: live-display requires Kitty terminal");
    console.error("Please run this command inside a Kitty terminal window.");
    process.exit(1);
  }

  const gitRoot = findGitRoot();
  const jsonPath = process.argv[2] || path.join(gitRoot, ".live-display.json");

  let pidPath: string;
  try {
    pidPath = await createPidFile(gitRoot);
  } catch (error: any) {
    console.error(`Error: ${error.message}`);
    process.exit(1);
    return;
  }

  console.log(`Watching: ${jsonPath}`);
  console.log(`PID file: ${pidPath}`);
  console.log("Press Ctrl+C to stop");

  if (!existsSync(jsonPath)) {
    console.log(`Creating display file: ${jsonPath}`);
    try {
      await writeFile(jsonPath, JSON.stringify({ items: [] }, null, 2));
      console.log("Created empty display file. Add items to see content.");
    } catch (error: any) {
      await removePidFile(pidPath);
      console.error(`Error creating display file: ${error.message}`);
      process.exit(1);
    }
  }

  const handler = new DisplayHandler(jsonPath);
  await handler.checkToolAvailability();
  await handler.updateDisplay();

  let jsonWatcher: FSWatcher | null = null;
  let cleaningUp = false;
  const attachJsonWatcher = () => {
    jsonWatcher = watch(jsonPath, (eventType) => {
      if (eventType === 'rename') {
        jsonWatcher.close();
        if (existsSync(jsonPath)) {
          attachJsonWatcher();
        }
        handler.scheduleUpdate();
        return;
      }

      if (eventType === 'change') {
        handler.scheduleUpdate();
      }
    });
  };
  attachJsonWatcher();

  const cleanup = async (exitCode: number = 0) => {
    if (cleaningUp) {
      return;
    }
    cleaningUp = true;

    if (jsonWatcher) {
      jsonWatcher.close();
    }
    handler.cleanupFileWatchers();
    await handler.cleanupAllTempDirs();
    await removePidFile(pidPath);

    if (exitCode === 0) {
      console.log("\nStopped watching");
    }
    process.exit(exitCode);
  };

  process.on("SIGWINCH", () => handler.scheduleUpdate());
  process.on("SIGINT", () => { void cleanup(0); });
  process.on("SIGTERM", () => { void cleanup(0); });
  process.on("SIGHUP", () => { void cleanup(0); });
  process.on("uncaughtException", (error) => {
    console.error(`Uncaught exception: ${error.message}`);
    void cleanup(1);
  });
  process.on("unhandledRejection", (error) => {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`Unhandled rejection: ${message}`);
    void cleanup(1);
  });

  // Never resolves -- keeps the process alive
  await new Promise(() => {});
}
main().catch(console.error);

// vim: ft=typescript
