#!/usr/bin/env bun
import { watch, type FSWatcher } from "fs";
import { readFile, writeFile, unlink, mkdtemp, rm, readdir, appendFile } from "fs/promises";
import { existsSync } from "fs";
import { tmpdir } from "os";
import path from "path";

const HELP_TEXT = `Usage: live-display [JSON_FILE]

Watches a JSON file and displays diagrams/images in Kitty terminal.

Arguments:
  JSON_FILE    Path to JSON file (default: .live-display.json in git root)

Supported diagram types: plantuml, dot, gnuplot, ditaa
Supported image types: png, jpg, jpeg, gif, bmp, webp, svg
`;

const EXTENSION_TYPE_MAP: Record<string, string> = {
  '.puml': 'plantuml',
  '.plantuml': 'plantuml',
  '.dot': 'dot',
  '.gv': 'dot',
  '.gp': 'gnuplot',
  '.gnuplot': 'gnuplot',
  '.plt': 'gnuplot',
  '.ditaa': 'ditaa',
  '.dta': 'ditaa',
  '.png': 'image',
  '.jpg': 'image',
  '.jpeg': 'image',
  '.gif': 'image',
  '.bmp': 'image',
  '.webp': 'image',
  '.svg': 'image',
};

interface DiagramTool {
  name: string;
  available: boolean;
  tempPrefix: string;
  inputExtension: string;
  prepareContent?: (content: string, outputPath: string) => string;
  run: (inputPath: string, outputPath: string, tempDir: string) => Promise<string>;
}

async function logToFile(message: string, logFilePath: string): Promise<void> {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] ${message}\n`;
  try {
    await appendFile(logFilePath, logMessage);
  } catch {
    // Ignore logging errors
  }
}

function getTypeFromExtension(filePath: string): string {
  const ext = path.extname(filePath).toLowerCase();
  const type = EXTENSION_TYPE_MAP[ext];
  if (!type) {
    throw new Error(`Unsupported file extension: ${ext}`);
  }
  return type;
}

function findGitRoot(startPath: string = process.cwd()): string {
  let currentPath = path.resolve(startPath);

  while (currentPath !== path.dirname(currentPath)) {
    const gitPath = path.join(currentPath, '.git');
    if (existsSync(gitPath)) {
      return currentPath;
    }
    currentPath = path.dirname(currentPath);
  }

  // If no .git found, fall back to current working directory
  return process.cwd();
}

async function createPidFile(gitRoot: string): Promise<string> {
  const pidPath = path.join(gitRoot, ".live-display.pid");

  // Check for stale PID file from a previous run
  if (existsSync(pidPath)) {
    try {
      const oldPid = parseInt(await readFile(pidPath, "utf-8"), 10);
      if (!isNaN(oldPid)) {
        try {
          process.kill(oldPid, 0); // Throws if process doesn't exist
          console.warn(`Warning: another live-display process (PID ${oldPid}) appears to be running.`);
        } catch {
          // Process not running — stale PID file, safe to overwrite
        }
      }
    } catch {
      // Can't read PID file — overwrite it
    }
  }

  await writeFile(pidPath, process.pid.toString());
  return pidPath;
}

async function removePidFile(pidPath: string): Promise<void> {
  try {
    if (existsSync(pidPath)) {
      await unlink(pidPath);
    }
  } catch {
    // Ignore errors when removing PID file
  }
}

interface DisplayItem {
  type?: string;
  content?: string;
  file?: string;
  title?: string;
}

interface DisplayData {
  items: DisplayItem[];
}

function validateDisplayData(data: unknown): DisplayData {
  if (!data || typeof data !== "object") {
    throw new Error("Invalid JSON: expected an object");
  }

  const obj = data as Record<string, unknown>;

  if (!Array.isArray(obj.items)) {
    throw new Error("Invalid JSON: 'items' must be an array");
  }

  const items: DisplayItem[] = [];
  for (let i = 0; i < obj.items.length; i++) {
    const item = obj.items[i];
    if (!item || typeof item !== "object") {
      throw new Error(`Invalid JSON: item ${i} must be an object`);
    }

    const itemObj = item as Record<string, unknown>;

    // Must have either 'file' or both 'type' and 'content'
    const hasFile = itemObj.file !== undefined;
    const hasTypeContent = itemObj.type !== undefined && itemObj.content !== undefined;

    if (!hasFile && !hasTypeContent) {
      throw new Error(`Invalid JSON: item ${i} must have either 'file' or both 'type' and 'content'`);
    }

    if (hasFile && hasTypeContent) {
      throw new Error(`Invalid JSON: item ${i} cannot have both 'file' and 'type'/'content' - choose one approach`);
    }

    if (itemObj.file !== undefined && typeof itemObj.file !== "string") {
      throw new Error(`Invalid JSON: item ${i} 'file' must be a string`);
    }

    if (itemObj.type !== undefined && typeof itemObj.type !== "string") {
      throw new Error(`Invalid JSON: item ${i} 'type' must be a string`);
    }

    if (itemObj.content !== undefined && typeof itemObj.content !== "string") {
      throw new Error(`Invalid JSON: item ${i} 'content' must be a string`);
    }

    if (itemObj.title !== undefined && typeof itemObj.title !== "string") {
      throw new Error(`Invalid JSON: item ${i} 'title' must be a string if provided`);
    }

    items.push({
      type: itemObj.type as string | undefined,
      content: itemObj.content as string | undefined,
      file: itemObj.file as string | undefined,
      title: itemObj.title as string | undefined,
    });
  }

  return { items };
}

class DisplayHandler {
  private jsonPath: string;
  private gitRoot: string;
  private logFilePath: string;
  private diagramTools: Record<string, DiagramTool> = {};
  private activeTempDirs = new Set<string>();
  private previousTempDirs = new Set<string>();
  private fileWatchers = new Map<string, FSWatcher>();
  private updateTimeout: ReturnType<typeof setTimeout> | null = null;
  private updating = false;
  private pendingUpdate = false;
  private readonly DEBOUNCE_MS = 100;

  constructor(jsonPath: string) {
    this.jsonPath = path.resolve(jsonPath);
    this.gitRoot = findGitRoot();
    this.logFilePath = path.join(this.gitRoot, '.live-display.log');
    this.initializeDiagramTools();
    // Truncate log file on startup
    Bun.write(this.logFilePath, `[${new Date().toISOString()}] live-display started (PID ${process.pid})\n`);
  }

  private initializeDiagramTools(): void {
    this.diagramTools = {
      plantuml: {
        name: 'PlantUML',
        available: false,
        tempPrefix: 'live-display-puml-',
        inputExtension: '.puml',
        run: async (inputPath, _outputPath, tempDir) => {
          await this.runCommand(['plantuml', '-tpng', '-o', tempDir, inputPath], 'PlantUML');
          // PlantUML names output based on input file, so find the generated PNG
          const files = await readdir(tempDir);
          const pngFiles = files.filter(f => f.endsWith('.png'));
          if (pngFiles.length === 0) {
            throw new Error("No PNG file generated by PlantUML");
          }
          return path.join(tempDir, pngFiles[0]);
        },
      },
      dot: {
        name: 'Graphviz DOT',
        available: false,
        tempPrefix: 'live-display-dot-',
        inputExtension: '.dot',
        run: async (inputPath, outputPath) => {
          await this.runCommand(['dot', '-Tpng', inputPath, '-o', outputPath], 'Graphviz');
          return outputPath;
        },
      },
      gnuplot: {
        name: 'Gnuplot',
        available: false,
        tempPrefix: 'live-display-gnuplot-',
        inputExtension: '.gp',
        prepareContent: (content, outputPath) => {
          // Check if script already has terminal settings (only match uncommented lines)
          const hasTerminal = /^\s*set\s+term(inal)?[\s]/im.test(content);
          const hasOutput = /^\s*set\s+out(put)?[\s]/im.test(content);

          if (!hasTerminal || !hasOutput) {
            // Prepend PNG terminal settings if not present
            return `set terminal png size 800,600\nset output "${outputPath}"\n${content}`;
          }
          return content;
        },
        run: async (inputPath, outputPath) => {
          await this.runCommand(['gnuplot', inputPath], 'Gnuplot');
          return outputPath;
        },
      },
      ditaa: {
        name: 'Ditaa',
        available: false,
        tempPrefix: 'live-display-ditaa-',
        inputExtension: '.ditaa',
        run: async (inputPath, outputPath) => {
          await this.runCommand(['ditaa', inputPath, outputPath], 'Ditaa');
          return outputPath;
        },
      },
    };
  }

  async initialize(): Promise<void> {
    await this.checkToolAvailability();
  }

  private async checkToolAvailability(): Promise<void> {
    const checks: [string, string[]][] = [
      ['plantuml', ['plantuml', '-version']],
      ['dot', ['dot', '-V']],
      ['gnuplot', ['gnuplot', '--version']],
      ['ditaa', ['ditaa', '--help']],
    ];

    for (const [toolName, command] of checks) {
      try {
        const proc = Bun.spawn(command, { stdout: 'pipe', stderr: 'pipe' });
        await proc.exited;
        this.diagramTools[toolName].available = proc.exitCode === 0;
      } catch {
        this.diagramTools[toolName].available = false;
      }
    }
  }

  private async runCommand(command: string[], toolName: string): Promise<void> {
    await logToFile(`Running: ${command.join(' ')}`, this.logFilePath);
    const proc = Bun.spawn(command, { stdout: 'pipe', stderr: 'pipe' });

    await proc.exited;
    await logToFile(`${toolName} exit code: ${proc.exitCode}`, this.logFilePath);

    if (proc.exitCode !== 0) {
      const stderr = await new Response(proc.stderr).text();
      await logToFile(`${toolName} stderr: ${stderr}`, this.logFilePath);
      throw new Error(`${toolName} failed: ${stderr}`);
    }
  }

  private resolveFilePath(filePath: string): string {
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    return path.join(this.gitRoot, filePath);
  }

  scheduleUpdate(): void {
    if (this.updateTimeout) {
      clearTimeout(this.updateTimeout);
    }
    this.updateTimeout = setTimeout(() => this.updateDisplay(), this.DEBOUNCE_MS);
  }

  async updateDisplay(): Promise<void> {
    if (this.updating) {
      this.pendingUpdate = true;
      return;
    }
    this.updating = true;

    try {
      // Clean up temp dirs from the render *before* the previous one
      await this.cleanupPreviousTempDirs();

      // Move current active dirs to previous (still readable by kitty icat)
      this.previousTempDirs = this.activeTempDirs;
      this.activeTempDirs = new Set<string>();

      const content = await readFile(this.jsonPath, "utf-8");
      const parsed: unknown = JSON.parse(content);
      const data = validateDisplayData(parsed);

      // Extract all referenced files
      const referencedFiles = new Set<string>();
      for (const item of data.items) {
        if (item.file) {
          referencedFiles.add(this.resolveFilePath(item.file));
        }
      }

      // Update file watchers
      await this.updateFileWatchers(referencedFiles);

      // Clear terminal
      console.clear();

      // Display all items
      for (let i = 0; i < data.items.length; i++) {
        const item = data.items[i];

        // Add separator between items (except for first item)
        if (i > 0) {
          console.log("\n" + "-".repeat(50) + "\n");
        }

        await this.displayItem(item);
      }

    } catch (error: any) {
      if (error.code === "ENOENT") {
        console.log(`Waiting for ${this.jsonPath} to be created...`);
      } else if (error instanceof SyntaxError) {
        console.log(`Error parsing JSON: ${error.message}`);
      } else {
        console.log(`Error: ${error.message}`);
      }
    } finally {
      this.updating = false;
      if (this.pendingUpdate) {
        this.pendingUpdate = false;
        this.scheduleUpdate();
      }
    }
  }

  private async displayItem(item: DisplayItem): Promise<void> {
    // Display title if provided
    if (item.title) {
      console.log(`\n${item.title}\n`);
    }

    let displayType: string;
    let content: string;
    let isFile = false;

    if (item.file) {
      // File-based rendering: determine type from extension and read content
      displayType = getTypeFromExtension(item.file);
      isFile = true;

      const filePath = this.resolveFilePath(item.file);

      if (!existsSync(filePath)) {
        console.log(`File not found: ${filePath}`);
        return;
      }

      if (displayType === 'image') {
        // For images, we use the file path directly
        content = filePath;
      } else {
        // For diagrams, read the file content
        try {
          content = await readFile(filePath, 'utf-8');
        } catch (error: any) {
          console.log(`Error reading file ${filePath}: ${error.message}`);
          return;
        }
      }
    } else {
      // Inline content rendering (validated by validateDisplayData)
      displayType = item.type!;
      content = item.content!;
    }

    // Route to appropriate display handler
    if (displayType === "image") {
      if (isFile) {
        try {
          await this.displayImage(content);
        } catch (error: any) {
          await logToFile(`Error displaying image: ${error.message}`, this.logFilePath);
          console.log(`Error displaying image: ${error.message}`);
        }
      } else {
        console.log(`Inline image content not supported`);
      }
    } else if (this.diagramTools[displayType]) {
      await this.displayDiagramFromContent(displayType, content);
    } else {
      console.log(`Unsupported display type: ${displayType}`);
    }
  }

  private async displayImage(imagePath: string): Promise<void> {
    await logToFile(`Displaying image: ${imagePath}`, this.logFilePath);

    if (!existsSync(imagePath)) {
      throw new Error(`Image file not found: ${imagePath}`);
    }

    const proc = Bun.spawn(["kitty", "+kitten", "icat", imagePath], {
      stdout: "inherit",
      stderr: "pipe",
      stdin: "inherit",
    });

    await proc.exited;
    await logToFile(`kitty icat exit code: ${proc.exitCode}`, this.logFilePath);

    if (proc.exitCode !== 0) {
      const stderr = await new Response(proc.stderr).text();
      // Ignore ImageMagick warnings which are not actual errors
      if (stderr && !stderr.includes("ImageMagick")) {
        await logToFile(`kitty icat stderr: ${stderr}`, this.logFilePath);
        throw new Error(`Image display failed: ${stderr}`);
      }
    } else {
      await logToFile("Image display completed successfully", this.logFilePath);
    }
  }

  private async displayDiagramFromContent(toolName: string, content: string): Promise<void> {
    const tool = this.diagramTools[toolName];

    if (!tool.available) {
      console.log(`${tool.name} is not available on this system`);
      return;
    }

    await logToFile(`Rendering ${tool.name} diagram`, this.logFilePath);

    try {
      // Create temp directory
      const tempDir = await mkdtemp(path.join(tmpdir(), tool.tempPrefix));
      this.activeTempDirs.add(tempDir);

      // Prepare paths
      const outputPath = path.join(tempDir, "output.png");
      const inputPath = path.join(tempDir, `input${tool.inputExtension}`);

      // Prepare and write content (some tools need modification)
      const preparedContent = tool.prepareContent
        ? tool.prepareContent(content, outputPath)
        : content;
      await writeFile(inputPath, preparedContent);

      // Run the tool and display the result
      const actualOutputPath = await tool.run(inputPath, outputPath, tempDir);
      await this.displayImage(actualOutputPath);

    } catch (error: any) {
      await logToFile(`Error in ${tool.name} rendering: ${error.message}`, this.logFilePath);
      console.log(`Error rendering ${tool.name}: ${error.message}`);
    }
  }

  private async cleanupTempDirSet(dirs: Set<string>): Promise<void> {
    for (const tempDir of dirs) {
      try {
        if (existsSync(tempDir)) {
          await rm(tempDir, { recursive: true, force: true });
        }
      } catch (error: any) {
        // Log but don't fail cleanup
        console.warn(`Failed to cleanup ${tempDir}: ${error.message}`);
      }
    }
    dirs.clear();
  }

  private async cleanupPreviousTempDirs(): Promise<void> {
    await this.cleanupTempDirSet(this.previousTempDirs);
  }

  async cleanupAllTempDirs(): Promise<void> {
    await this.cleanupTempDirSet(this.previousTempDirs);
    await this.cleanupTempDirSet(this.activeTempDirs);
  }

  private async updateFileWatchers(referencedFiles: Set<string>): Promise<void> {
    // Remove watchers for files no longer referenced
    for (const [watchedFile, watcher] of this.fileWatchers) {
      if (!referencedFiles.has(watchedFile)) {
        watcher.close();
        this.fileWatchers.delete(watchedFile);
        await logToFile(`Stopped watching: ${watchedFile}`, this.logFilePath);
      }
    }

    // Add watchers for new files
    for (const file of referencedFiles) {
      if (!this.fileWatchers.has(file) && existsSync(file)) {
        const watcher = watch(file, async (eventType) => {
          if (eventType === "change") {
            await logToFile(`Detected change in: ${file}`, this.logFilePath);
            this.scheduleUpdate();
          }
        });
        this.fileWatchers.set(file, watcher);
        await logToFile(`Now watching: ${file}`, this.logFilePath);
      }
    }
  }

  cleanupFileWatchers(): void {
    for (const [, watcher] of this.fileWatchers) {
      watcher.close();
    }
    this.fileWatchers.clear();
  }
}

async function main(): Promise<void> {
  // Handle --help option
  if (process.argv.includes('--help') || process.argv.includes('-h')) {
    console.log(HELP_TEXT);
    process.exit(0);
  }

  // Check for Kitty terminal
  if (!process.env.KITTY_WINDOW_ID) {
    console.error("Error: live-display requires Kitty terminal");
    console.error("Please run this command inside a Kitty terminal window.");
    process.exit(1);
  }

  // Find git root and determine JSON file path
  const gitRoot = findGitRoot();
  const jsonPath = process.argv[2] || path.join(gitRoot, ".live-display.json");

  // Create PID file to indicate live-display is running
  const pidPath = await createPidFile(gitRoot);

  console.log(`Watching: ${jsonPath}`);
  console.log(`PID file: ${pidPath}`);
  console.log("Press Ctrl+C to stop");

  // Create JSON file if it doesn't exist
  if (!existsSync(jsonPath)) {
    console.log(`Creating display file: ${jsonPath}`);
    const initialContent = {
      items: []
    };
    try {
      await writeFile(jsonPath, JSON.stringify(initialContent, null, 2));
      console.log(`Created empty display file. Add items to see content.`);
    } catch (error: any) {
      await removePidFile(pidPath);
      console.error(`Error creating display file: ${error.message}`);
      process.exit(1);
    }
  }

  // Set up display handler
  const handler = new DisplayHandler(jsonPath);

  // Initialize tool availability checking
  await handler.initialize();

  // Display initial content
  await handler.updateDisplay();

  // Watch JSON file for changes using inotify-based fs.watch
  const jsonWatcher = watch(jsonPath, (eventType) => {
    if (eventType === "change") {
      handler.scheduleUpdate();
    }
  });

  // Cleanup function
  const cleanup = async () => {
    jsonWatcher.close();
    handler.cleanupFileWatchers();
    await handler.cleanupAllTempDirs();
    await removePidFile(pidPath);
    console.log("\nStopped watching");
    process.exit(0);
  };

  // Re-render on terminal resize
  process.on("SIGWINCH", () => handler.scheduleUpdate());

  // Handle Ctrl+C and other termination signals
  process.on("SIGINT", cleanup);
  process.on("SIGTERM", cleanup);
  process.on("SIGHUP", cleanup);

  // Keep the process running
  await new Promise(() => {
    // This promise never resolves, keeping the process alive
  });
}

// Run the main function
main().catch(console.error);

// vim: ft=typescript
