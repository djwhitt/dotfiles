#!/usr/bin/env bun
import { watchFile, unwatchFile } from "fs";
import { readFile, writeFile, unlink, mkdtemp, rm, readdir, appendFile } from "fs/promises";
import { existsSync } from "fs";
import { tmpdir } from "os";
import path from "path";

const HELP_TEXT = `Usage: live-display [JSON_FILE]

Watches a JSON file and displays diagrams/images in Kitty terminal.

Arguments:
  JSON_FILE    Path to JSON file (default: .live-display.json in git root)

Supported diagram types: plantuml, dot, gnuplot, ditaa
Supported image types: png, jpg, jpeg, gif, bmp, webp, svg
`;

const EXTENSION_TYPE_MAP: Record<string, string> = {
  '.puml': 'plantuml',
  '.plantuml': 'plantuml',
  '.dot': 'dot',
  '.gv': 'dot',
  '.gp': 'gnuplot',
  '.gnuplot': 'gnuplot',
  '.plt': 'gnuplot',
  '.ditaa': 'ditaa',
  '.dta': 'ditaa',
  '.png': 'image',
  '.jpg': 'image',
  '.jpeg': 'image',
  '.gif': 'image',
  '.bmp': 'image',
  '.webp': 'image',
  '.svg': 'image',
};

interface DiagramTool {
  name: string;
  available: boolean;
  tempPrefix: string;
  inputExtension: string;
  prepareContent?: (content: string, outputPath: string) => string;
  run: (inputPath: string, outputPath: string, tempDir: string) => Promise<string>;
}

async function logToFile(message: string, logFilePath: string): Promise<void> {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] ${message}\n`;
  try {
    await appendFile(logFilePath, logMessage);
  } catch {
    // Ignore logging errors
  }
}

function getTypeFromExtension(filePath: string): string {
  const ext = path.extname(filePath).toLowerCase();
  const type = EXTENSION_TYPE_MAP[ext];
  if (!type) {
    throw new Error(`Unsupported file extension: ${ext}`);
  }
  return type;
}

function findGitRoot(startPath: string = process.cwd()): string {
  let currentPath = path.resolve(startPath);

  while (currentPath !== path.dirname(currentPath)) {
    const gitPath = path.join(currentPath, '.git');
    if (existsSync(gitPath)) {
      return currentPath;
    }
    currentPath = path.dirname(currentPath);
  }

  // If no .git found, fall back to current working directory
  return process.cwd();
}

async function createPidFile(gitRoot: string): Promise<string> {
  const pidPath = path.join(gitRoot, ".live-display.pid");
  await writeFile(pidPath, process.pid.toString());
  return pidPath;
}

async function removePidFile(pidPath: string): Promise<void> {
  try {
    if (existsSync(pidPath)) {
      await unlink(pidPath);
    }
  } catch {
    // Ignore errors when removing PID file
  }
}

interface DisplayItem {
  type?: string;
  content?: string;
  file?: string;
  title?: string;
}

interface DisplayData {
  items: DisplayItem[];
}

function validateDisplayData(data: unknown): DisplayData {
  if (!data || typeof data !== "object") {
    throw new Error("Invalid JSON: expected an object");
  }

  const obj = data as Record<string, unknown>;

  if (!Array.isArray(obj.items)) {
    throw new Error("Invalid JSON: 'items' must be an array");
  }

  const items: DisplayItem[] = [];
  for (let i = 0; i < obj.items.length; i++) {
    const item = obj.items[i];
    if (!item || typeof item !== "object") {
      throw new Error(`Invalid JSON: item ${i} must be an object`);
    }

    const itemObj = item as Record<string, unknown>;

    // Must have either 'file' or both 'type' and 'content'
    const hasFile = itemObj.file !== undefined;
    const hasTypeContent = itemObj.type !== undefined && itemObj.content !== undefined;

    if (!hasFile && !hasTypeContent) {
      throw new Error(`Invalid JSON: item ${i} must have either 'file' or both 'type' and 'content'`);
    }

    if (hasFile && hasTypeContent) {
      throw new Error(`Invalid JSON: item ${i} cannot have both 'file' and 'type'/'content' - choose one approach`);
    }

    if (itemObj.file !== undefined && typeof itemObj.file !== "string") {
      throw new Error(`Invalid JSON: item ${i} 'file' must be a string`);
    }

    if (itemObj.type !== undefined && typeof itemObj.type !== "string") {
      throw new Error(`Invalid JSON: item ${i} 'type' must be a string`);
    }

    if (itemObj.content !== undefined && typeof itemObj.content !== "string") {
      throw new Error(`Invalid JSON: item ${i} 'content' must be a string`);
    }

    if (itemObj.title !== undefined && typeof itemObj.title !== "string") {
      throw new Error(`Invalid JSON: item ${i} 'title' must be a string if provided`);
    }

    items.push({
      type: itemObj.type as string | undefined,
      content: itemObj.content as string | undefined,
      file: itemObj.file as string | undefined,
      title: itemObj.title as string | undefined,
    });
  }

  return { items };
}

class DisplayHandler {
  private jsonPath: string;
  private gitRoot: string;
  private logFilePath: string;
  private diagramTools: Record<string, DiagramTool> = {};
  private activeTempDirs = new Set<string>();
  private watchedFiles = new Set<string>();
  private updateTimeout: ReturnType<typeof setTimeout> | null = null;
  private readonly DEBOUNCE_MS = 100;

  constructor(jsonPath: string) {
    this.jsonPath = path.resolve(jsonPath);
    this.gitRoot = findGitRoot();
    this.logFilePath = path.join(this.gitRoot, '.live-display.log');
    this.initializeDiagramTools();
  }

  private initializeDiagramTools(): void {
    this.diagramTools = {
      plantuml: {
        name: 'PlantUML',
        available: false,
        tempPrefix: 'live-display-puml-',
        inputExtension: '.puml',
        run: async (inputPath, _outputPath, tempDir) => {
          await this.runCommand(['plantuml', '-tpng', '-o', tempDir, inputPath], 'PlantUML');
          // PlantUML names output based on input file, so find the generated PNG
          const files = await readdir(tempDir);
          const pngFiles = files.filter(f => f.endsWith('.png'));
          if (pngFiles.length === 0) {
            throw new Error("No PNG file generated by PlantUML");
          }
          return path.join(tempDir, pngFiles[0]);
        },
      },
      dot: {
        name: 'Graphviz DOT',
        available: false,
        tempPrefix: 'live-display-dot-',
        inputExtension: '.dot',
        run: async (inputPath, outputPath) => {
          await this.runCommand(['dot', '-Tpng', inputPath, '-o', outputPath], 'Graphviz');
          return outputPath;
        },
      },
      gnuplot: {
        name: 'Gnuplot',
        available: false,
        tempPrefix: 'live-display-gnuplot-',
        inputExtension: '.gp',
        prepareContent: (content, outputPath) => {
          // Check if script already has terminal settings (only match uncommented lines)
          const hasTerminal = /^\s*set\s+terminal/im.test(content);
          const hasOutput = /^\s*set\s+output/im.test(content);

          if (!hasTerminal || !hasOutput) {
            // Prepend PNG terminal settings if not present
            return `set terminal png size 800,600\nset output "${outputPath}"\n${content}`;
          }
          return content;
        },
        run: async (inputPath, outputPath) => {
          await this.runCommand(['gnuplot', inputPath], 'Gnuplot');
          return outputPath;
        },
      },
      ditaa: {
        name: 'Ditaa',
        available: false,
        tempPrefix: 'live-display-ditaa-',
        inputExtension: '.ditaa',
        run: async (inputPath, outputPath) => {
          await this.runCommand(['ditaa', inputPath, outputPath], 'Ditaa');
          return outputPath;
        },
      },
    };
  }

  async initialize(): Promise<void> {
    await this.checkToolAvailability();
  }

  private async checkToolAvailability(): Promise<void> {
    const checks: [string, string[]][] = [
      ['plantuml', ['plantuml', '-version']],
      ['dot', ['dot', '-V']],
      ['gnuplot', ['gnuplot', '--version']],
      ['ditaa', ['ditaa', '--help']],
    ];

    for (const [toolName, command] of checks) {
      try {
        const proc = Bun.spawn(command, { stdout: 'pipe', stderr: 'pipe' });
        await proc.exited;
        this.diagramTools[toolName].available = proc.exitCode === 0;
      } catch {
        this.diagramTools[toolName].available = false;
      }
    }
  }

  private async runCommand(command: string[], toolName: string): Promise<void> {
    await logToFile(`Running: ${command.join(' ')}`, this.logFilePath);
    const proc = Bun.spawn(command, { stdout: 'pipe', stderr: 'pipe' });

    await proc.exited;
    await logToFile(`${toolName} exit code: ${proc.exitCode}`, this.logFilePath);

    if (proc.exitCode !== 0) {
      const stderr = await new Response(proc.stderr).text();
      await logToFile(`${toolName} stderr: ${stderr}`, this.logFilePath);
      throw new Error(`${toolName} failed: ${stderr}`);
    }
  }

  scheduleUpdate(): void {
    if (this.updateTimeout) {
      clearTimeout(this.updateTimeout);
    }
    this.updateTimeout = setTimeout(() => this.updateDisplay(), this.DEBOUNCE_MS);
  }

  async updateDisplay(): Promise<void> {
    try {
      // Clean up temp files from previous render
      await this.cleanupAllTempDirs();

      const content = await readFile(this.jsonPath, "utf-8");
      const parsed: unknown = JSON.parse(content);
      const data = validateDisplayData(parsed);

      // Extract all referenced files
      const referencedFiles = new Set<string>();
      for (const item of data.items) {
        if (item.file) {
          // Resolve relative paths relative to git root
          let filePath = path.resolve(item.file);
          if (!path.isAbsolute(item.file)) {
            filePath = path.join(this.gitRoot, item.file);
          }
          referencedFiles.add(filePath);
        }
      }

      // Update file watchers
      await this.updateFileWatchers(referencedFiles);

      // Clear terminal
      console.clear();

      // Display all items
      for (let i = 0; i < data.items.length; i++) {
        const item = data.items[i];

        // Add separator between items (except for first item)
        if (i > 0) {
          console.log("\n" + "-".repeat(50) + "\n");
        }

        await this.displayItem(item);
      }

    } catch (error: any) {

      if (error.code === "ENOENT") {
        console.log(`Waiting for ${this.jsonPath} to be created...`);
      } else if (error instanceof SyntaxError) {
        console.log(`Error parsing JSON: ${error.message}`);
      } else {
        console.log(`Error: ${error.message}`);
      }
    }
  }

  private async displayItem(item: DisplayItem): Promise<void> {
    // Display title if provided
    if (item.title) {
      console.log(`\n${item.title}\n`);
    }

    let displayType: string;
    let content: string;
    let isFile = false;

    if (item.file) {
      // File-based rendering: determine type from extension and read content
      displayType = getTypeFromExtension(item.file);
      isFile = true;

      // Resolve relative paths relative to git root
      let filePath = path.resolve(item.file);
      if (!path.isAbsolute(item.file)) {
        filePath = path.join(this.gitRoot, item.file);
      }

      if (!existsSync(filePath)) {
        console.log(`File not found: ${filePath}`);
        return;
      }

      if (displayType === 'image') {
        // For images, we use the file path directly
        content = filePath;
      } else {
        // For diagrams, read the file content
        try {
          content = await readFile(filePath, 'utf-8');
        } catch (error: any) {
          console.log(`Error reading file ${filePath}: ${error.message}`);
          return;
        }
      }
    } else if (item.type && item.content) {
      // Inline content rendering
      displayType = item.type;
      content = item.content;
    } else {
      console.log(`Invalid item: must have either 'file' or both 'type' and 'content'`);
      return;
    }

    // Route to appropriate display handler
    if (displayType === "image") {
      if (isFile) {
        await this.displayImageFromPath(content);
      } else {
        console.log(`Inline image content not supported`);
      }
    } else if (this.diagramTools[displayType]) {
      await this.displayDiagramFromContent(displayType, content);
    } else {
      console.log(`Unsupported display type: ${displayType}`);
    }
  }

  private async displayImageFromPath(imagePath: string): Promise<void> {
    // Build kitty icat command
    const cmd = ["kitty", "+kitten", "icat", imagePath];

    try {
      // Use spawn for better control over the kitty process
      const proc = Bun.spawn(cmd, {
        stdout: "inherit",
        stderr: "pipe",  // Pipe stderr to suppress ImageMagick warnings
        stdin: "inherit",
      });

      // Wait for process to complete
      await proc.exited;

      // Only show errors if exit code is non-zero
      if (proc.exitCode !== 0) {
        const stderr = await new Response(proc.stderr).text();
        if (stderr && !stderr.includes("ImageMagick")) {
          console.error(`Error displaying image: ${stderr}`);
        }
      }
    } catch (error: any) {
      console.log(`Error displaying image: ${error.message}`);
    }
  }

  private async displayGeneratedImage(imagePath: string): Promise<void> {
    await logToFile(`Displaying image: ${imagePath}`, this.logFilePath);

    if (!existsSync(imagePath)) {
      await logToFile(`Image file does not exist: ${imagePath}`, this.logFilePath);
      throw new Error(`Generated image not found: ${imagePath}`);
    }

    await logToFile(`Image file exists, proceeding with kitty icat`, this.logFilePath);

    // Reuse existing kitty icat logic
    const proc = Bun.spawn(["kitty", "+kitten", "icat", imagePath], {
      stdout: "inherit",
      stderr: "pipe",
      stdin: "inherit",
    });

    await proc.exited;
    await logToFile(`kitty icat exit code: ${proc.exitCode}`, this.logFilePath);

    if (proc.exitCode !== 0) {
      const stderr = await new Response(proc.stderr).text();
      await logToFile(`kitty icat stderr: ${stderr}`, this.logFilePath);
      if (stderr && !stderr.includes("ImageMagick")) {
        throw new Error(`Image display failed: ${stderr}`);
      }
    } else {
      await logToFile("Image display completed successfully", this.logFilePath);
    }
  }

  private async displayDiagramFromContent(toolName: string, content: string): Promise<void> {
    const tool = this.diagramTools[toolName];

    await logToFile(`Starting ${tool.name} rendering`, this.logFilePath);

    if (!tool.available) {
      await logToFile(`${tool.name} is not available on this system`, this.logFilePath);
      console.log(`${tool.name} is not available on this system`);
      return;
    }

    await logToFile(`${tool.name} is available, proceeding with rendering`, this.logFilePath);

    try {
      // Create temp directory
      let tempBase = tmpdir();
      if (!existsSync(tempBase)) {
        tempBase = "/tmp";
      }
      const tempDir = await mkdtemp(path.join(tempBase, tool.tempPrefix));
      await logToFile(`Created temp directory: ${tempDir}`, this.logFilePath);
      this.activeTempDirs.add(tempDir);

      // Prepare output path
      const outputPath = path.join(tempDir, `output.png`);

      // Prepare content (some tools need modification)
      const preparedContent = tool.prepareContent
        ? tool.prepareContent(content, outputPath)
        : content;

      // Create input file
      const inputPath = path.join(tempDir, `input${tool.inputExtension}`);
      await writeFile(inputPath, preparedContent);
      await logToFile(`Wrote ${tool.name} content to: ${inputPath}`, this.logFilePath);
      await logToFile(`Content length: ${preparedContent.length} chars`, this.logFilePath);

      // Run the tool
      await logToFile(`Running ${tool.name} command...`, this.logFilePath);
      const actualOutputPath = await tool.run(inputPath, outputPath, tempDir);
      await logToFile(`${tool.name} command completed`, this.logFilePath);

      // Check if output was generated
      if (existsSync(actualOutputPath)) {
        await logToFile(`PNG file exists, size: ${(await readFile(actualOutputPath)).length} bytes`, this.logFilePath);
      } else {
        await logToFile("PNG file does not exist!", this.logFilePath);
        const dirContents = await readdir(tempDir);
        await logToFile(`Directory contents: ${JSON.stringify(dirContents)}`, this.logFilePath);
      }

      // Display the generated image
      await logToFile("Attempting to display image...", this.logFilePath);
      await this.displayGeneratedImage(actualOutputPath);
      await logToFile("Image display completed", this.logFilePath);

    } catch (error: any) {
      await logToFile(`Error in ${tool.name} rendering: ${error.message}`, this.logFilePath);
      await logToFile(`Error stack: ${error.stack || 'No stack'}`, this.logFilePath);
      console.log(`Error rendering ${tool.name}: ${error.message}`);
    }

    await logToFile(`${tool.name} rendering complete`, this.logFilePath);
  }

  async cleanupAllTempDirs(): Promise<void> {
    for (const tempDir of this.activeTempDirs) {
      try {
        if (existsSync(tempDir)) {
          await rm(tempDir, { recursive: true, force: true });
        }
      } catch (error: any) {
        // Log but don't fail cleanup
        console.warn(`Failed to cleanup ${tempDir}: ${error.message}`);
      }
    }
    this.activeTempDirs.clear();
  }

  private async updateFileWatchers(referencedFiles: Set<string>): Promise<void> {
    // Remove watchers for files no longer referenced
    for (const watchedFile of this.watchedFiles) {
      if (!referencedFiles.has(watchedFile)) {
        unwatchFile(watchedFile);
        this.watchedFiles.delete(watchedFile);
        await logToFile(`Stopped watching: ${watchedFile}`, this.logFilePath);
      }
    }

    // Add watchers for new files
    for (const file of referencedFiles) {
      if (!this.watchedFiles.has(file) && existsSync(file)) {
        watchFile(file, { interval: 1000 }, async (curr, prev) => {
          // Check if file has been modified (mtime changed)
          if (curr.mtime !== prev.mtime) {
            await logToFile(`Detected change in: ${file}`, this.logFilePath);
            this.scheduleUpdate();
          }
        });
        this.watchedFiles.add(file);
        await logToFile(`Now watching: ${file}`, this.logFilePath);
      }
    }
  }

  cleanupFileWatchers(): void {
    // Remove all file watchers
    for (const watchedFile of this.watchedFiles) {
      unwatchFile(watchedFile);
    }
    this.watchedFiles.clear();
  }
}

async function main(): Promise<void> {
  // Handle --help option
  if (process.argv.includes('--help') || process.argv.includes('-h')) {
    console.log(HELP_TEXT);
    process.exit(0);
  }

  // Check for Kitty terminal
  if (!process.env.KITTY_WINDOW_ID) {
    console.error("Error: live-display requires Kitty terminal");
    console.error("Please run this command inside a Kitty terminal window.");
    process.exit(1);
  }

  // Find git root and determine JSON file path
  const gitRoot = findGitRoot();
  let jsonPath: string;
  if (process.argv.length > 2 && process.argv[2]) {
    jsonPath = process.argv[2];
  } else {
    // Default to .live-display.json in git root
    jsonPath = path.join(gitRoot, ".live-display.json");
  }

  // Create PID file to indicate live-display is running
  const pidPath = await createPidFile(gitRoot);

  console.log(`Watching: ${jsonPath}`);
  console.log(`PID file: ${pidPath}`);
  console.log("Press Ctrl+C to stop");

  // Create JSON file if it doesn't exist
  if (!existsSync(jsonPath)) {
    console.log(`Creating display file: ${jsonPath}`);
    const initialContent = {
      items: []
    };
    try {
      await writeFile(jsonPath, JSON.stringify(initialContent, null, 2));
      console.log(`Created empty display file. Add items to see content.`);
    } catch (error: any) {
      await removePidFile(pidPath);
      console.error(`Error creating display file: ${error.message}`);
      process.exit(1);
    }
  }

  // Set up display handler
  const handler = new DisplayHandler(jsonPath);

  // Initialize tool availability checking
  await handler.initialize();

  // Display initial content
  await handler.updateDisplay();

  // Set up file watcher with polling for better reliability
  // watchFile polls the file every interval (default 5007ms)
  // This is more reliable than fs.watch for detecting file changes
  watchFile(jsonPath, { interval: 1000 }, async (curr, prev) => {
    // Check if file has been modified (mtime changed)
    if (curr.mtime !== prev.mtime) {
      handler.scheduleUpdate();
    }
  });

  // Cleanup function
  const cleanup = async () => {
    unwatchFile(jsonPath);
    handler.cleanupFileWatchers();
    await handler.cleanupAllTempDirs();
    await removePidFile(pidPath);
    console.log("\nStopped watching");
    process.exit(0);
  };

  // Handle Ctrl+C and other termination signals
  process.on("SIGINT", cleanup);
  process.on("SIGTERM", cleanup);
  process.on("SIGHUP", cleanup);

  // Keep the process running
  await new Promise(() => {
    // This promise never resolves, keeping the process alive
  });
}

// Run the main function
main().catch(console.error);

// vim: ft=typescript
